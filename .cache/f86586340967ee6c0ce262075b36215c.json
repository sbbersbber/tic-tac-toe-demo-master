{"dependencies":[{"name":"lodash","loc":{"line":8,"column":14}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require(\"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass AI {\n  constructor(chessBoard, player, depth, alpha, beta) {\n    this.chessBoard = chessBoard;\n    this.depth = depth;\n    this.role = player;\n    this.pos = null;\n    this.childNode = null;\n    this.alpha = alpha || -Infinity;\n    this.beta = beta || Infinity;\n  }\n\n  /**\r\n  * the core algorithm with alpha-beta \r\n  * for player, role 'x', hope the min score\r\n  * for computer, role 'o', hope the max score\r\n  */\n  getHopedScore() {\n    // check winner\n    const winner = this.checkIfHaveAWinner();\n    if (winner) {\n      return winner === 'o' ? 10 : winner === 'draw' ? 0 : -10;\n    }\n\n    if (this.depth >= 100) return 0; // no limit to depth\n\n    // get all available pos\n    const availablePos = _lodash2.default.shuffle(this.calcAvailablePos());\n    // core maxmin -> alpha-beta\n    if (this.role === 'o') {\n      let maxValue = -1000;\n      for (let i = 0; i < availablePos.length >>> 0; i++) {\n        const pos = availablePos[i];\n        const newBoard = this.generateNewChessBoard(pos, this.role);\n        const childStateNode = new AI(newBoard, changeRole(this.role), this.depth + 1, this.alpha, this.beta);\n        const childHopedScore = childStateNode.getHopedScore();\n        if (childHopedScore > maxValue) {\n          maxValue = childHopedScore;\n          this.childNode = childStateNode;\n          this.pos = pos;\n          this.alpha = maxValue;\n        }\n        if (this.alpha >= this.beta) {\n          break;\n        }\n      }\n      return maxValue;\n    } else {\n      let minValue = 1000;\n      for (let i = 0; i < availablePos.length >>> 0; i++) {\n        const pos = availablePos[i];\n        const newBoard = this.generateNewChessBoard(pos, this.role);\n        const childStateNode = new AI(newBoard, changeRole(this.role), this.depth + 1, this.alpha, this.beta);\n        const childHopedScore = childStateNode.getHopedScore();\n        if (childHopedScore < minValue) {\n          minValue = childHopedScore;\n          this.childNode = childStateNode;\n          this.pos = pos;\n          this.beta = minValue;\n        }\n        if (this.alpha >= this.beta) {\n          break;\n        }\n      }\n      return minValue;\n    }\n  }\n\n  /**\r\n  * this func will return the winner role like 'x' or 'o';\r\n  * if have a draw ,return 'draw', else return false;\r\n  */\n  checkIfHaveAWinner() {\n    // cols\n    for (let i = 0; i < this.chessBoard.length; i++) {\n      let row = this.chessBoard[i];\n      if (row.join('').trim() === 'xxx') {\n        return 'x';\n      } else if (row.join('').trim() === 'ooo') {\n        return 'o';\n      }\n    }\n    // rows\n    if (this.chessBoard[0][0] + this.chessBoard[1][0] + this.chessBoard[2][0] === 'xxx' || this.chessBoard[0][0] + this.chessBoard[1][0] + this.chessBoard[2][0] === 'ooo') {\n      return this.chessBoard[0][0];\n    } else if (this.chessBoard[0][1] + this.chessBoard[1][1] + this.chessBoard[2][1] === 'xxx' || this.chessBoard[0][1] + this.chessBoard[1][1] + this.chessBoard[2][1] === 'ooo') {\n      return this.chessBoard[0][1];\n    } else if (this.chessBoard[0][2] + this.chessBoard[1][2] + this.chessBoard[2][2] === 'xxx' || this.chessBoard[0][2] + this.chessBoard[1][2] + this.chessBoard[2][2] === 'ooo') {\n      return this.chessBoard[0][2];\n    }\n    // slash\n    if (this.chessBoard[0][0] + this.chessBoard[1][1] + this.chessBoard[2][2] === 'xxx' || this.chessBoard[0][0] + this.chessBoard[1][1] + this.chessBoard[2][2] === 'ooo') {\n      return this.chessBoard[0][0];\n    } else if (this.chessBoard[0][2] + this.chessBoard[1][1] + this.chessBoard[2][0] === 'xxx' || this.chessBoard[0][2] + this.chessBoard[1][1] + this.chessBoard[2][0] === 'ooo') {\n      return this.chessBoard[0][2];\n    }\n\n    // draw\n    let flag = true;\n    for (let i = 0; i < this.chessBoard.length; i++) {\n      for (let j = 0; j < this.chessBoard[i].length; j++) {\n        if (!this.chessBoard[i][j]) {\n          flag = false;\n        }\n      }\n    }\n\n    if (flag) return 'draw';\n\n    return false;\n  }\n\n  /**\r\n  * get the available pos\r\n  */\n  calcAvailablePos() {\n    const availablePos = [];\n    for (let i = 0; i < this.chessBoard.length; i++) {\n      for (let j = 0; j < this.chessBoard[i].length; j++) {\n        if (!this.chessBoard[i][j]) {\n          availablePos.push([i, j]);\n        }\n      }\n    }\n    return availablePos;\n  }\n\n  /**\r\n  * generate a new chess board\r\n  */\n  generateNewChessBoard(pos, role) {\n    const fakeChessBoard = _lodash2.default.cloneDeep(this.chessBoard);\n    fakeChessBoard[pos[0]][pos[1]] = role;\n    return fakeChessBoard;\n  }\n  /**\r\n  * next board state\r\n  */\n  next() {\n    this.chessBoard = _lodash2.default.cloneDeep(this.childNode.chessBoard);\n  }\n}\n\nexports.default = AI; /*\r\n                      * @Author: huangteng\r\n                      * @Date:   2018-04-20 11:08:51\r\n                      * @Last Modified by:   huangteng\r\n                      * @Last Modified time: 2018-04-20 16:37:30\r\n                      * @Description: use alpha-beta\r\n                      */\n\nconst changeRole = role => {\n  return role === 'x' ? 'o' : 'x';\n};"},"hash":"3a4668fd3a76c9ebd69ee7df2051ad75"}